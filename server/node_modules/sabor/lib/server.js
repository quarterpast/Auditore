(function(){
  var http, Q, qs, url, Timer, __slice = [].slice;
  http = require('q-http');
  Q = require('q');
  qs = require('querystring');
  url = require('url');
  Timer = (function(){
    Timer.displayName = 'Timer';
    var prototype = Timer.prototype, constructor = Timer;
    function _ctor(){} _ctor.prototype = prototype;
    function Timer(id){
      var _this = new _ctor;
      _this.id = id;
      console.time(id);
      return _this;
    }
    prototype.end = function(){
      return console.timeEnd(this.id);
    };
    return Timer;
  }());
  exports.Serve = function(routes){
    var server, _this = this;
    server = http.Server(function(req){
      var uri, t, p, route, reg, m, args, a, _ref, _ref2, _res, _i, _len;
      uri = url.parse(req.url);
      req.get = uri.query;
      req.post = req.method === 'POST'
        ? req.body.read().then(function(data){
          return qs.parse(data.toString('utf8'));
        })
        : Q.when({});
      t = Timer(process.pid + " " + req.connection.remoteAddress + " " + req.path);
      for (p in _ref = routes) {
        route = _ref[p];
        reg = RegExp("^" + p + "$");
        if (!reg.test(uri.pathname)) {
          continue;
        }
        _ref2 = reg.exec(uri.pathname), m = _ref2[0], args = __slice.call(_ref2, 1);
        _res = [];
        for (_i = 0, _len = args.length; _i < _len; ++_i) {
          a = args[_i];
          if (a == +a) {
            _res.push(+a);
          } else {
            _res.push(a);
          }
        }
        args = _res;
        return Q.when(route.apply(null, [req].concat(__slice.call(args)))).then(_fn);
      }
      return {
        status: 404,
        body: ["fail " + req.path],
        onclose: function(){
          return t.end();
        }
      };
      function _fn(res){
        if (typeof res === 'object' && !(res instanceof Buffer)) {
          return __import({
            onclose: __bind(t, 'end')
          }, res);
        }
        return {
          body: res.forEach != null
            ? res
            : [res],
          status: 200,
          onclose: __bind(t, 'end')
        };
      }
    });
    return server.add = function(more){
      return __import(routes, more);
    }, server;
  };
  function __import(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
  function __bind(obj, key){
    return function(){ return obj[key].apply(obj, arguments) };
  }
}).call(this);
